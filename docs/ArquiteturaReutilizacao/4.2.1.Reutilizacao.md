# Módulo de reutilização de software

## 1. Introdução

&emsp;&emsp;A reutilização de software consiste em aproveitar conceitos, produtos ou soluções existentes para criar novos softwares, com o objetivo de aprimorar a qualidade e a produtividade. Esse processo envolve a utilização de partes de sistemas anteriores, tais como especificações, módulos, arquitetura e código-fonte. A reutilização tem como meta principal elevar a qualidade e reduzir o tempo de desenvolvimento. Pode ser aplicada em diferentes etapas do ciclo de desenvolvimento, como requisitos, design e implementação. Atualmente, há várias técnicas de reuso disponíveis, tais como o uso de frameworks, a adoção de arquiteturas orientadas a serviços (SOA) e a prática de engenharia de software baseada em componentes.


## 2. Backend

### 2.1 Notificação - Adapter

#### 2.1.1 - Análise de HotsSpots e FrozenSpots

Uma breve introdução dos termos, Hotspots são áreas de um software que são mais propensas a mudanças, normalmente apresentando alta complexidade e alto acoplamento. Essas áreas estão sujeitas a alterações frequentes devido a requisitos em constante evolução, mudanças no ambiente ou outros fatores. Identificar hotspots é importante para direcionar esforços de manutenção e refatoração para as áreas mais críticas do sistema. Já FrozenSpots são áreas de baixo acoplamento e baixa complexidade, são areas do software que raramente mudam.

![Adapter](adapter.png)

<figcaption align='center'>
    <b>Figura 1: Representação Design Pattern Adapter representado no diagrama de classes</b>
    <br><small>Fonte: Elaboração Própria</small>
</figcaption> </center>

No contexto do Adapter, a classe ServiceMail representa um **hotspot** porque é responsável por fornecer um serviço de envio de e-mails para os Sellers. Como geralmente os serviços de e-mail são delegados a pacotes terceiros ou serviços externos, a classe ServiceMail pode depender tanto da classe Seller quanto de pacotes ou APIs externas. Isso significa que qualquer alteração nos pacotes terceiros ou nas dependências externas pode afetar as mudanças necessárias na classe ServiceMail.

Em relação à classe Seller, ela representa uma entidade e, dificilmente mudará. As entidades são tipicamente consideradas como parte das camadas mais baixas da arquitetura, como a camada de domínio ou a camada de persistência. Essas classes são independentes de classes de níveis superiores e tendem a ter menor dependência em relação a outras classes de alto nível.

Como a classe Seller está em camadas de baixo nível, ela é menos propensa a depender de outras classes de alto nível, o que a torna menos suscetível a mudanças resultantes de alterações de classes em camadas de alto nível, portanto representa um possível **FrozenSpot**, da aplicação.

Concluindo temos que, a classe ServiceMail representa um hotspot devido às suas dependências de alto nível, como a classe Seller e pacotes terceiros. A classe Seller representa um FrozenSpot, por ser uma entidade em camadas mais baixas, tende a ser mais estável e ter menor dependência em relação a outras classes de alto nível.

### 2.2 Anexos - Decorator

### 2.3 Filtros - Strategy e Decorator

Ao longo da fase de "Padrões de Projeto GoFs", foi desenvolvido uma combinação de Padrões, **Strategy** e **Decorator**, visando implementar as funcionalidades de filtragem de avaliação dos produtos do Mercado Livre.

Baseado Figura 1 de Diagrama de Classes, é possível identificar os seguintes classes **Hot-Spots**: FilterStrategy, QualificationStrategy e BaseQualificationDecorator. É possivel considerá-las **Hot-Spots** pois são componentes genéricos, sendo adaptáveis as necessidades das aplicações no geral 

![Filtros - StrategyDecorator](https://github.com/UnBArqDsw2023-1/2023.1_G2_ProjetoMercadoLivre/assets/64036847/0f4b571b-0692-4634-bdd8-b70bbfacaa0f)

<figcaption align='center'>
    <b>Figura 2: Diagrama do padrão Strategy e Decorator para a funcionalidade de filtrar avaliações dos produtos</b>
    <br><small>Fonte: Elaboração Própria</small>
</figcaption> </center>

Usando a Linguagem TypeScritp (TS), que é baseada em Orientação a Objetos, e pensando nos componentes e na Reutilização de Software, foi possível importar as classes para o arquivo [StrategyDecoratorClient.ts](https://github.com/UnBArqDsw2023-1/2023.1_G2_ProjetoMercadoLivre/blob/design-patterns/src/strategyDecorator/StrategyDecoratorClient.ts). As classes importadas são reutilizados no decorrer do código, exemplificando as estratégias de filtro: MostRelevantStrategy, MostRecentlyStrategy e ConcreteQualificationStrategy. É importante frisar que os filtros são aplicados na avaliações, ou seja, o módulo Avaliation também é reutilizado.

        import { injectable } from 'inversify';
        import { Client } from '../interfaces/Client.js';
        import Avaliation from './Avaliation.js';
        import Filter from './filter/Filter.js';
        import MostRelevantStrategy from './Strategys/MostRelevantStrategy.js';
        import MostRecentlyStrategy from './Strategys/MostRecentlyStrategy.js';
        import ConcreteQualificationStrategy from './concrete/ConcreteQualificationStrategy.js';
        import FiveStarsDecorator from './decorators/FiveStarsDecorator.js';
        import FourStarsDecorator from './decorators/FourStarsDecorator.js';
        import ThreeStarsDecorator from './decorators/ThreeStarsDecorator.js';
        import TwoStarsDecorator from './decorators/TwoStarsDecorator.js';

        @injectable()
        export default class StrategyDecoratorClient implements Client {
        run(): void {
            const avaliation1 = new Avaliation(new Date(2023, 6, 16), 5, 22);
            const avaliation2 = new Avaliation(new Date(2022, 5, 1), 3, 10);
            const avaliation3 = new Avaliation(new Date(2021, 3, 10), 2, 5);
            const avaliation4 = new Avaliation(new Date(2020, 6, 16), 1, 2);
            const avaliation5 = new Avaliation(new Date(2019, 6, 16), 4, 80);

            const avaliationList: Avaliation[] = [
            avaliation1,
            avaliation2,
            avaliation3,
            avaliation4,
            avaliation5,
            ];

            console.log(
            '------------- Filtrando avaliação por relevancia ---------------'
            );

            const filter = new Filter(new MostRelevantStrategy(), avaliationList);
            filter.filterAvaliation();

            console.log(
            '------------- Filtrando avaliação mais recente ---------------'
            );
            filter.setStrategy(new MostRecentlyStrategy());
            filter.filterAvaliation();

            console.log(
            '--------------- Filtrando por qualificacao - 5 estrelas ------------------'
            );
            const concreteDecorator = new ConcreteQualificationStrategy(avaliationList);
            const fiveStarsDecorator = new FiveStarsDecorator(
            concreteDecorator,
            avaliationList
            );
            filter.setStrategy(fiveStarsDecorator);
            filter.filterAvaliation();

            console.log(
            '--------------- Filtrando por qualificacao - 4 estrelas ------------------'
            );
            const fourStarsDecorator = new FourStarsDecorator(
            concreteDecorator,
            avaliationList
            );
            filter.setStrategy(fourStarsDecorator);
            filter.filterAvaliation();

            console.log(
            '--------------- Filtrando por qualificacao - 3 estrelas ------------------'
            );
            const threeStarsDecorator = new ThreeStarsDecorator(
            concreteDecorator,
            avaliationList
            );
            filter.setStrategy(threeStarsDecorator);
            filter.filterAvaliation();

            console.log(
            '--------------- Filtrando por qualificacao - 2 estrelas ------------------'
            );
            const twoStarsDecorator = new TwoStarsDecorator(
            concreteDecorator,
            avaliationList
            );
            filter.setStrategy(twoStarsDecorator);
            filter.filterAvaliation();
        }
        }


### 2.4 Compressão Arquivos - Template



## Referências


## Histórico de versões

| Versão |     Alteração     |  Responsável  | Revisor  | Data  |
| :----: | :---------------: | :-----------: | :------: | :---: |
|  1.0   | Criando documento | João Henrique | Leonardo | 02/07 |
|  1.1   | Adicionando Strategy e Decorator | Leonardo | Arthur | 02/07 |
|  1.2   | Adicionando Adapter | Arthur | Leonardo | 02/07 |
|  1.3   | Adicionando mais informações ao Adapter | Arthur | Leonardo | 02/07 |
