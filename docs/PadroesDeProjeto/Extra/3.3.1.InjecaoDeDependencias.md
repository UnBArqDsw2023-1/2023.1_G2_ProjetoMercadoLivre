# Injeção de Dependência

## Introdução
O padrão de projeto Injeção de Dependências é um padrão de design que promove a inversão de controle e separação de responsabilidades ao remover a criação e resolução de dependências de dentro de uma classe e fornecer essas dependências de fora. Isso permite que as classes sejam mais flexíveis, testáveis e desacopladas de suas dependências.

## Objetivo
O objetivo do padrão Injeção de Dependências é reduzir o acoplamento entre classes, permitindo que dependências sejam fornecidas de forma flexível e substituíveis. Isso torna o código mais modular, testável e extensível, pois as classes não estão mais diretamente acopladas a implementações específicas de suas dependências.


## Participantes
Os participantes da criação do interfato de injeção de dependência foram:

- Christian Fleury Alencar de Siqueira
- Cícero Barrozo Fernandes Filho
- Thiago Siqueira Gomes

## Metodologia



## Problemática e Solução



## UML



## Código
Na implementação da Injeção de Dependência, foi utilizado a biblioteca inversify.

````
import { Container, ContainerModule, interfaces } from 'inversify';
import { AvailableChoices } from './MainMenu.js';
import { ClientsToken } from './ExamplesFactory.js';
import TemplateClient from './template/TemplateClient.js';
import AdapterClient from './adapter/AdapterClient.js';
import ContentDecoratorClient from './contentDecorator/ContentDecoratorClient.js';
import { Client } from './interfaces/Client.js';
import StrategyDecoratorClient from './strategyDecorator/StrategyDecoratorClient.js';

export const container = new Container();

export const examplesModule = new ContainerModule((bind: interfaces.Bind) => {
  bind<Client>(ClientsToken)
    .to(TemplateClient)
    .whenTargetNamed(AvailableChoices.TEMPLATE);

  bind<Client>(ClientsToken)
    .to(AdapterClient)
    .whenTargetNamed(AvailableChoices.ADAPTER);

  bind<Client>(ClientsToken)
    .to(ContentDecoratorClient)
    .whenTargetNamed(AvailableChoices.DECORATOR);

  bind<Client>(ClientsToken)
    .to(StrategyDecoratorClient)
    .whenTargetNamed(AvailableChoices.STRATEGYDECORATOR);
});
```

Primeiro, importamos as classes necessárias do inversify e outras classes relacionadas. Em seguida, criamos uma instância do recipiente Container, que será responsável por gerenciar as dependências e a resolução das instâncias das classes. Depois, definimos um módulo chamado "examplesModule" usando "ContainerModule". 

O módulo é uma forma de agrupar as dependências relacionadas. Passamos uma função que recebe o objeto bind do tipo "interfaces.Bind", que nos permite registrar as dependências no recipiente. Dentro dessa função, usamos o método bind para registrar as diferentes classes de clientes e associá-las a um tipo específico (ClientsToken).



## Conclusão


## Referências
Martin Fowler, "Inversion of Control Containers and the Dependency Injection pattern": https://martinfowler.com/articles/injection.html

## Versionamento

| Versão | Alteração | Responsável | Revisor | Data |
| :-: | :-: | :-: | :-: | :-: |
|  1.0   | Adiciona de injeção de dependencias| Thiago Gomes  |  Christian Fleury  | 11/06/23  |